# https://esphome.io/guides/configuration-types.html#substitutions
substitutions:

  # substitutions can be changed here if you are using this file directly in the ESPHome dashboard.  The better approach is
  # to incorporate this file as a package using the following lines, and then overwrite these substitutions in your local
  # yaml file by redefining them.
  #
  #

  name: dc-s31-tool-sensor         # **** CHANGE DEVICE NAME TO SOMETHING UNIQUE PER DEVICE.  RENAME YAML FILE TO SAME NAME.    ****
                               # **** USE DASHES (-) INSTEAD OF SPACES OR UNDERSCORE (_).  USE ONLY LOWER CASE LETTERS.     ****

  friendly_name: Dust Collector Tool Sensor     # **** CHANGE FRIENDLY NAME TO SOMETHING UNIQUE PER DEVICE ****

  disable_entities:  "true"    # set to "false" to have all entities show up in Home Assistant automatically
  disable_webserver: "false"   # set to "true" to disable webserver listening on port 80.

  wifi_ap_timeout: 2min    # default to 2 minute timeout for yaml file as package.

  # https://esphome.io/components/esphome.html#esphome-creators-project
  project_name: buzzkc.dust_collector_control
  project_ver_num: "1.0.1"
  project_ver_let: t

  sub_import_url: github://buzzkc/docker-dust-collector/dc-S31-tool-sensor.yaml@v1

  sub_ota_num_attempts: '15'

  device_type: "tool"
  mqtt_prefix: "buzzkc/dc" 
  relay_pin: 12 # Relay
  led_pin: 13 # Push button LED
  #servo1_pin: 5 
  #servo2_pin: 4
  switch_pin: 0 # Push button
  current_pin: 0 # A0


# https://esphome.io/components/esp8266.html
esp8266:
  board: esp01_1m


# https://esphome.io/components/esphome.html
esphome:

  name: $name
  friendly_name: $friendly_name
  project:
    name: $project_name
    version: $project_ver_num($project_ver_let)

  on_boot:
    priority: 800
    then:
      - light.turn_off: device_led
      - script.execute: led_wait_heartbeat

  min_version: 2025.10.0

# This should point to the public location of this yaml file.
dashboard_import:
  package_import_url: $sub_import_url
  import_full_config: false # or true


# https://esphome.io/components/wifi.html
wifi:
  ap:
    ap_timeout: $wifi_ap_timeout


# https://esphome.io/components/captive_portal.html
captive_portal:



# https://esphome.io/components/api.html
api:


# https://esphome.io/components/ota.html
ota:
  - platform: esphome

safe_mode:
  num_attempts: $sub_ota_num_attempts

# https://esphome.io/components/web_server.html
web_server:

# Device Specific Config
#<<: !include dc-sonoff-s31-template-header.yaml   

# https://esphome.io/components/logger.html
logger:
  baud_rate: 0 # (0 = disabled, UART logging interferes with cse7766)
  level: ERROR
  logs:
    sensor: ERROR # (Overide any global setting, to VERBOSE will spamming the cse7766 sensors)

globals:
  - id: relay_trigger_source
    type: std::string
    restore_value: no
    initial_value: '"none"'
  - id: off_routine_running
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: current_trigger
    type: float
    restore_value: no
    initial_value: '2.0'

mqtt:
  broker: !secret mqtt_broker  # ðŸ”¹ Replace with your MQTT broker IP or hostname
  discovery: false
  topic_prefix: ${mqtt_prefix}/${device_name}
  reboot_timeout: 0s
  birth_message:
    topic: ${mqtt_prefix}/${device_name}/birth
    payload: "{\"type\":\"${device_type}\", \"state\":\"birth\"}"
    qos: 2
  will_message:
    topic: ${mqtt_prefix}/${device_name}/will
    payload: "{\"type\":\"${device_type}\", \"state\":\"will\"}"
    qos: 2

  # Send MQTT message when device comes online
  on_connect:
    then:
      - output.turn_off: led_output
      - script.stop: led_wait_heartbeat
      - script.execute: led_heartbeat
      - mqtt.publish:
          topic: ${mqtt_prefix}/${device_name}/status
          payload: '{"state":"online"}'

  # Send MQTT message when device goes offline
  on_disconnect:
    then:
      - output.turn_off: led_output
      - script.stop: led_heartbeat
      - script.execute: led_wait_heartbeat
      - mqtt.publish:
          topic: ${mqtt_prefix}/${device_name}/status
          payload: '{"state":"offline"}'

  on_json_message:
    - topic: ${mqtt_prefix}/${device_name}/config
      then:
        - lambda: |-
            if (x["currentTrigger"]) {
              id(current_trigger) = x["currentTrigger"].as<float>();
              //ESP_LOGI("mqtt", "Updated current_trigger to: %.2f", id(current_trigger));
            }
    - topic: ${mqtt_prefix}/lock/cmd
      then:
        - lambda: |-
            if (x["command"]) {
              std::string state = x["command"].as<std::string>();
              if (state == "unlock") {
                id(relay_1).turn_on();
              } else if (state == "lock"){
                id(relay_1).turn_off();
              }
            }


uart:
  rx_pin: RX
  baud_rate: 4800
  parity: EVEN

binary_sensor:
  - platform: gpio
    pin:
      number: ${switch_pin}
      mode: INPUT_PULLUP
      inverted: True
    id: button
    #filters:
    #  - delayed_on: 50ms    # debounce for press
    #  - delayed_off: 50ms   # debounce for release
    on_click:
    - min_length: 50ms
      max_length: 500ms
      then:
        - if:
            condition:
              lambda: |-
                    return id(relay_1).state;
            then:
              - if:
                  condition:
                    lambda: |-
                          return (id(off_routine_running) == false) && id(relay).state;
                  then:
                    - mqtt.publish:
                        topic: ${mqtt_prefix}/${device_name}
                        payload: !lambda | 
                          char buffer[64];
                          snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"off\", \"current\":%.2f}", id(current_raw).state);
                          return std::string(buffer);
                        qos: 2
                    - script.execute: toggle_relay

                  else:
                    # Interrupt any pending off routine before turning on
                    - script.stop: relay_off_routine
                    - lambda: 'id(off_routine_running) = false;'
                    - lambda: 'id(relay_trigger_source) = "button";'
                    - mqtt.publish:
                        topic: ${mqtt_prefix}/${device_name}
                        payload: !lambda | 
                          char buffer[64];
                          snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"on\", \"current\":%.2f}", id(current_raw).state);
                          return std::string(buffer);
                        qos: 2
                    - script.execute: relay_on_routine
    - min_length: 2000ms
      max_length: 5000ms
      then:
        - switch.toggle: relay_1
        - mqtt.publish:
            topic: ${mqtt_prefix}/lock/cmd
            payload: !lambda | 
              char buffer[64];
              snprintf(buffer, sizeof(buffer), "{\"name\": \"${device_name}\", \"command\":%s}", (id(relay_1).state)?"\"unlock\"":"\"lock\"");
              return std::string(buffer);

  - platform: status
    id: platform_status
    #name: "Sonoff S31 Status"

sensor:
  - platform: wifi_signal
    id: wifi_info
    #name: "Sonoff S31 WiFi Signal"
    update_interval: 60s
  - platform: cse7766
    current:
      id: current_raw
      #name: "Sonoff S31 Current"
      accuracy_decimals: 2
      filters:
        - throttle_average: 1s
      on_value_range:
      - above: !lambda 'return id(current_trigger) + .01;'
        then:
          - if:
              condition:
                lambda: |-
                  return ((id(off_routine_running) == true) && id(relay).state) || !(id(relay).state);
              then:
                - lambda: 'id(relay_trigger_source) = "sensor";'
                - logger.log: "Current above 4A, relay triggered by current sensor"
                - mqtt.publish:
                    topic: ${mqtt_prefix}/${device_name}
                    payload: !lambda | 
                      char buffer[64];
                      snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"on\", \"current\":%.2f}", id(current_raw).state);
                      return std::string(buffer);
                    qos: 2
                - script.execute: toggle_relay
      - below: !lambda 'return id(current_trigger);'
        then:
          - if:
              condition:
                lambda: |-
                  return (id(relay_trigger_source) == "sensor") && id(relay).state;
              then:
                - logger.log: "Current dropped below 4A, relay turning off (sensor-triggered)"
                - mqtt.publish:
                    topic: ${mqtt_prefix}/${device_name}
                    payload: !lambda | 
                      char buffer[64];
                      snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"off\", \"current\":%.2f}", id(current_raw).state);
                      return std::string(buffer);
                    qos: 2
                - script.execute: relay_off_routine 
    voltage:
      #name: "Sonoff S31 Voltage"
      id: voltage
      accuracy_decimals: 2
      filters:
        - throttle_average: 60s

switch:
  - platform: gpio
    id: relay
    pin: 4 #or pin 5, just something that can be toggled.
    restore_mode: ALWAYS_OFF # Powering the relay may cause damage or instability when the programmer is supplying Vcc.

  - platform: gpio
    pin: ${relay_pin}
    id: relay_1
    restore_mode: ALWAYS_OFF # Powering the relay may cause damage or instability when the programmer is supplying Vcc.

time:
  - platform: sntp #(required for total_daily_energy)
    id: my_time

output:
  # LED output
  - platform: gpio
    pin: 
      number: ${led_pin}
      inverted: True
    id: led_output

light:
  - platform: binary
    id: device_led
    output: led_output

script:
  - id: relay_on_routine
    mode: restart
    then:
      - script.stop: led_heartbeat
      - switch.turn_on: relay
      - light.turn_on: device_led

  - id: relay_off_routine
    mode: restart
    then:
      - lambda: 'id(off_routine_running) = true;'
      # Flash LED for 10 seconds (500ms on / 500ms off)
      - repeat:
          count: 10
          then:
            - light.toggle: device_led
            - delay: 1s
      
      # Now turn off the relay
      - switch.turn_off: relay

      # Make sure LED is off (final state)
      - light.turn_off: device_led
      - script.execute: led_heartbeat
            
      # reset global variable to none that tracks if it was toggled on via the button or the current sensor      
      - lambda: 'id(relay_trigger_source) = "none";'
      - lambda: 'id(off_routine_running) = false;'

  - id: toggle_relay
    mode: restart
    then:
      - if:
          condition:
            lambda: |-
                  return (id(off_routine_running) == false) && id(relay).state;
          then:
            - script.execute: relay_off_routine
            
          else:
            # Interrupt any pending off routine before turning on
            - script.stop: relay_off_routine
            - lambda: 'id(off_routine_running) = false;'
            - script.execute: relay_on_routine
  
  - id: current_high
    mode: restart
    then:
      - if:
          condition:
            lambda: |-
              return ((id(off_routine_running) == true) && id(relay).state) || !(id(relay).state);
          then:
            - lambda: 'id(relay_trigger_source) = "sensor";'
            - logger.log: "Current above 4A, relay triggered by current sensor"
            - mqtt.publish:
                topic: ${mqtt_prefix}/${device_name}
                payload: !lambda | 
                  char buffer[64];
                  snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"on\", \"current\":%.2f}", id(current_raw).state);
                  return std::string(buffer);
                qos: 2
            - script.execute: toggle_relay
      
  - id: current_low
    mode: restart
    then:
      - if:
          condition:
            lambda: |-
              return (id(relay_trigger_source) == "sensor") && id(relay).state && (id(off_routine_running) == false);
          then:
            - logger.log: "Current dropped below 4A, relay turning off (sensor-triggered)"
            - mqtt.publish:
                topic: ${mqtt_prefix}/${device_name}
                payload: !lambda | 
                  char buffer[64];
                  snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"off\", \"current\":%.2f}", id(current_raw).state);
                  return std::string(buffer);
                qos: 2
            - script.execute: relay_off_routine 
# --- Heartbeat LED: double flash every 2 seconds ---
  - id: led_heartbeat
    mode: restart
    then:
      - logger.log: "LED heartbeat started (double flash every 2s)"
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.turn_on: device_led
            - delay: 100ms
            - light.turn_off: device_led
            - delay: 100ms
            - light.turn_on: device_led
            - delay: 100ms
            - light.turn_off: device_led
            - delay: 1700ms

# --- Wait Heartbeat LED: flash quickly once every 1 seconds ---
  - id: led_wait_heartbeat
    mode: restart
    then:
      - logger.log: "LED wait heartbeat started (flash once quickly every 1s)"
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.turn_on: device_led
            - delay: 100ms
            - light.turn_off: device_led
            - delay: 900ms

interval:
  - interval: 30s
    then:
      - mqtt.publish:
          topic: ${mqtt_prefix}/${device_name}/update
          payload: !lambda | 
            char buffer[64];
            snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\" ,\"state\":\"%s\", \"current\":%.2f}",
                     id(relay).state ? "on" : "off", id(current_raw).state);
            return std::string(buffer);   