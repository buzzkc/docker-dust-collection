[
    {
        "id": "73e45f7f5159bca6",
        "type": "tab",
        "label": "Dust Collection Control",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7b10c95849c94079",
        "type": "mqtt in",
        "z": "73e45f7f5159bca6",
        "name": "Get Dust Control Messages",
        "topic": "buzzkc/dc/#",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "0e8c6944103c09e3",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 80,
        "wires": [
            [
                "2231ea08498a3ae7",
                "24455f8b1229c1ec"
            ]
        ]
    },
    {
        "id": "2231ea08498a3ae7",
        "type": "debug",
        "z": "73e45f7f5159bca6",
        "name": "Debug Incoming Messages",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 420,
        "y": 60,
        "wires": []
    },
    {
        "id": "2b279b8e29b85dae",
        "type": "debug",
        "z": "73e45f7f5159bca6",
        "name": "Debug Outgoing Messages",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 720,
        "y": 80,
        "wires": []
    },
    {
        "id": "a48a661b76d4243a",
        "type": "mqtt out",
        "z": "73e45f7f5159bca6",
        "name": "Send Command",
        "topic": "",
        "qos": "2",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0e8c6944103c09e3",
        "x": 680,
        "y": 120,
        "wires": []
    },
    {
        "id": "fc32ca728c4b4bad",
        "type": "http in",
        "z": "73e45f7f5159bca6",
        "name": "Receive JSON Config Updates",
        "url": "/dc-config-update",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 150,
        "y": 380,
        "wires": [
            [
                "973e25281375a8b3",
                "d4512b2adfff9373"
            ]
        ]
    },
    {
        "id": "973e25281375a8b3",
        "type": "debug",
        "z": "73e45f7f5159bca6",
        "name": "Debug Incoming Body",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 420,
        "y": 380,
        "wires": []
    },
    {
        "id": "d4512b2adfff9373",
        "type": "json",
        "z": "73e45f7f5159bca6",
        "name": "Convert to json string",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 420,
        "y": 420,
        "wires": [
            [
                "4351df911f882eca",
                "649c7ced29db87e3"
            ]
        ]
    },
    {
        "id": "4351df911f882eca",
        "type": "debug",
        "z": "73e45f7f5159bca6",
        "name": "Debug JSON",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 420,
        "wires": []
    },
    {
        "id": "649c7ced29db87e3",
        "type": "file",
        "z": "73e45f7f5159bca6",
        "name": "Write to file system",
        "filename": "/data/dc-config.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 650,
        "y": 460,
        "wires": [
            [
                "ddb4d1ae1e0fe105"
            ]
        ]
    },
    {
        "id": "ddb4d1ae1e0fe105",
        "type": "debug",
        "z": "73e45f7f5159bca6",
        "name": "Debug File",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 850,
        "y": 440,
        "wires": []
    },
    {
        "id": "27f5faf70c4a58b5",
        "type": "inject",
        "z": "73e45f7f5159bca6",
        "name": "Update DC Config Local",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "300",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 150,
        "y": 220,
        "wires": [
            [
                "f273a54b55891170"
            ]
        ]
    },
    {
        "id": "bc6440f6ecda0a02",
        "type": "function",
        "z": "73e45f7f5159bca6",
        "name": "Set Global Config",
        "func": "let data = msg.payload;\nlet baseTopic = \"buzzkc/dc\";\n\n// --- STEP 1: Basic validation ---\nif (typeof data === \"string\") {\n    try {\n        data = JSON.parse(data);\n    } catch (err) {\n        node.error(\"Invalid JSON: cannot parse string\", msg);\n        return null; // stop flow\n    }\n}\n\nif (typeof data !== \"object\" || data === null) {\n    node.error(\"Invalid data: not an object\", msg);\n    return null;\n}\n\n// msg.payload is now the parsed JSON\nglobal.set(\"dc_config\", data);\n\n// Two maps weâ€™ll build\nlet sensorMap = {};\nlet collectorMap = {};\n// Recursive traversal function\nfunction traverse(nodeType, currentCollector = null, gateStack = []) {\n    // If nodeType is a collector, start a new entry\n    if (nodeType.nodeType.toLowerCase() === \"collector\") {\n        collectorMap[nodeType.name] = {\n            gates: [],\n            tools: []\n        };\n        currentCollector = nodeType.name;\n    }\n\n    // If nodeType is a gate, add to collectorMap and push to gateStack\n    if (nodeType.nodeType.toLowerCase() === \"gate\" && currentCollector) {\n        let gateEntry = { name: nodeType.name, gateNumber: nodeType.gateNumber };\n        collectorMap[currentCollector].gates.push(gateEntry);\n        gateStack.push(gateEntry);\n    }\n\n    // If nodeType is a tool, add to collectorMap and sensorMap\n    if (nodeType.nodeType.toLowerCase() === \"tool\" && currentCollector) {\n        collectorMap[currentCollector].tools.push(nodeType.name);\n\n        sensorMap[nodeType.name] = {\n            collector: currentCollector,\n            gates: [...gateStack], // clone current gateStack\n            triggerCurrent: nodeType.triggerCurrent\n        };\n\n        //send configurations to devices, currently only current_trigger values\n        let newMsg = {};\n        newMsg.topic = baseTopic + \"/\" + nodeType.name + \"/config\";\n        newMsg.payload = '{\"currentTrigger\":\"' + nodeType.triggerCurrent + '\"}';\n        node.log(newMsg);\n        node.send(newMsg);\n    }\n\n    // Recursively process children\n    if (nodeType.children && Array.isArray(nodeType.children)) {\n        for (let child of nodeType.children) {\n            traverse(child, currentCollector, gateStack);\n        }\n    }\n\n    // After processing children, if nodeType was a gate, pop it from stack\n    if (nodeType.nodeType.toLowerCase() === \"gate\" && gateStack.length > 0) {\n        gateStack.pop();\n    }\n}\n\n// Start traversal for each top-level nodeType\nfor (let nodeType of data) {\n    traverse(nodeType);\n}\n\n// Save both globally for use anywhere\nglobal.set(\"sensorMap\", sensorMap);\nglobal.set(\"collectorMap\", collectorMap);\n\n// Send both to debug for verification\nmsg.topic = \"buzzkc/dc/map-update\"\nmsg.payload = { sensorMap, collectorMap };\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 300,
        "wires": [
            [
                "d9e2fcbdd17f6934",
                "d093e19baf70ec51"
            ]
        ]
    },
    {
        "id": "d9e2fcbdd17f6934",
        "type": "debug",
        "z": "73e45f7f5159bca6",
        "name": "Debug Configuration Messages",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1030,
        "y": 280,
        "wires": []
    },
    {
        "id": "ec6dc06b4f82105c",
        "type": "debug",
        "z": "73e45f7f5159bca6",
        "name": "Debug JSON",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 750,
        "y": 260,
        "wires": []
    },
    {
        "id": "d093e19baf70ec51",
        "type": "mqtt out",
        "z": "73e45f7f5159bca6",
        "name": "Send Configs",
        "topic": "",
        "qos": "2",
        "retain": "true",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "0e8c6944103c09e3",
        "x": 980,
        "y": 320,
        "wires": []
    },
    {
        "id": "f273a54b55891170",
        "type": "file in",
        "z": "73e45f7f5159bca6",
        "name": "Get JSON Config File",
        "filename": "/data/dc-config.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 400,
        "y": 240,
        "wires": [
            [
                "70aec66f114611e8"
            ]
        ]
    },
    {
        "id": "70aec66f114611e8",
        "type": "json",
        "z": "73e45f7f5159bca6",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 590,
        "y": 280,
        "wires": [
            [
                "ec6dc06b4f82105c",
                "bc6440f6ecda0a02"
            ]
        ]
    },
    {
        "id": "24455f8b1229c1ec",
        "type": "function",
        "z": "73e45f7f5159bca6",
        "name": "New Parse Incoming Messages",
        "func": "/**\n * To-do: \n * Send api updates to monitor/web\n * Add global config to read on startup of Flow to send out device config to each device\n */\n\nlet baseTopic = \"buzzkc/dc\"; //may get from global later\nlet toolsRunning = context.get('toolsRunning') || []; //any tools that are currently running\nlet manualOverride = context.get('manualOverride') || []; //any controllers turned on manually from button on panel.\nlet sensorMap = global.get('sensorMap');\nlet collectorMap = global.get('collectorMap');\n\nlet status = \"\"; //on, off\nlet trigger = \"\"; //source of trigger, button or current\nlet type = \"\"; //controller, tool, gate, light\nlet current = \"\"; //value of tool current draw\nlet parent = \"\"; //parent of device\nlet gates = []; //any branch gates used by tool (not including ones it controls)\nlet currentTrigger = \"\";\n\nlet topic = msg.topic.split(\"/\"); \n\n//convert message to string type and parse json\nlet obj = JSON.stringify(msg.payload);\nlet data = JSON.parse(obj);\n\nif (data.type) {\n    type = data.type;\n}\n\nif (data.status) {\n    status = data.status;\n}\n\nif (data.trigger) {\n    trigger = data.trigger;\n}\n\nif (data.current) {\n    current = data.current; \n}\n\n\nif (type == \"tool\") {\n    parent = sensorMap[topic[2]]['collector'];\n    gates = sensorMap[topic[2]]['gates'];\n}\n\nif (type == \"controller\") {\n    gates = collectorMap[topic[2]]['gates'];\n}\n\n//open branch gates here if status is on and type is controller or tool\nif(Array.isArray(gates) && status === \"on\" && (type ===\"tool\" || (type = \"collector\" && topic[3] && topic[3] === \"manual\" ))) {\n    for (let i = 0; i < gates.length; i++) {\n        let newMsg = {};\n        newMsg.topic = baseTopic + \"/\" + gates[i]['name'] + \"/gate/cmd\";\n        newMsg.payload = '{\"device\":\"' + topic[2] + '\", \"status\":\"' + status + '\", \"command\":\"open\", \"gateNumber\":\"' + gates[i]['gateNumber'] + '\"}';\n        node.send(newMsg);\n    }\n}\n\n\n//check to see if birth message, controller may have restarted, check to see if it should be running.\nif (topic[3] && type === \"controller\" && topic[3] === \"birth\") {\n    \n    //check manualOverride for controller name\n    const index = manualOverride.indexOf(topic[2]); //find tool in running tool global array variable.\n    if (index !== -1) {\n        let newMsg = {};\n        newMsg.topic = baseTopic + \"/\" + topic[2] + \"/cmd\";\n        newMsg.payload = '{\"' + type + '\":\"' + topic[2] + '\", \"status\":\"' + status + '\", \"command\":\"on\"}';\n        node.send(newMsg);\n    }\n    \n    //check toolsRunning and see if any are for this controller, if so turn on the collector again\n    for (let i = 0; i < toolsRunning.length; i++) {\n        if(sensorMap[toolsRunning[i]][\"collector\"] === topic[2]) {\n            let newMsg = {};\n            newMsg.topic = baseTopic + \"/\" + topic[2] + \"/cmd\";\n            newMsg.payload = '{\"' + type + '\":\"' + toolsRunning[i] + '\", \"status\":\"' + status + '\", \"command\":\"on\"}';\n            node.send(newMsg);\n        }\n    }\n\n}\n\n//controller manually turned on\nif(topic[3] && type === \"controller\" && status === \"on\" && topic[3] === \"manual\") {\n    manualOverride.push(topic[2]); //add running tool to global array.\n    context.set('manualOverride', manualOverride);\n\n    let newMsg = {};\n    newMsg.topic = baseTopic + \"/\" + topic[2] + \"/on\";\n    newMsg.payload = '{\"' + type + '\":\"' + topic[2] + '\", \"status\":\"' + status + '\"}';\n    node.send(newMsg);\n}\n\n//controller manually turned off\nif (topic[3] && type === \"controller\" && status === \"off\" && topic[3] === \"manual\") {\n    const index = manualOverride.indexOf(topic[2]); //find tool in running tool global array variable.\n    if (index !== -1) {\n        manualOverride.splice(index, 1); // Removes 1 element at the found index\n        context.set('manualOverride', manualOverride);\n    }\n\n    let newMsg = {};\n    newMsg.topic = baseTopic + \"/\" + topic[2] + \"/off\";\n    newMsg.payload = '{\"' + type + '\":\"' + topic[2] + '\", \"status\":\"' + status + '\"}';\n    node.send(newMsg);\n\n    //close all branch gates here\n    if (Array.isArray(gates)) {\n        for (let i = 0; i < gates.length; i++) {\n            let newMsg = {};\n            newMsg.topic = baseTopic + \"/\" + gates[i]['name'] + \"/gate/cmd\";\n            newMsg.payload = '{\"device\":\"' + topic[2] + '\", \"status\":\"' + status + '\", \"command\":\"close\", \"gateNumber\":\"' + gates[i]['gateNumber'] + '\"}';\n            node.send(newMsg);\n        }\n    }\n}\n\nif (type === \"tool\" && status === \"on\") {\n\n    const index = toolsRunning.indexOf(topic[2]); //find tool in running tool global array variable.\n    if (index == -1) {\n        toolsRunning.push(topic[2]); //add running tool to global array.\n        context.set('toolsRunning', toolsRunning);\n    }\n\n    let newMsg = {};\n    newMsg.topic = baseTopic + \"/\" + parent + \"/cmd\";\n    newMsg.payload = '{\"' + type + '\":\"' + topic[2] + '\", \"status\":\"' + status + '\", \"command\":\"on\"}';\n    node.send(newMsg);\n}\n\nif (type === \"tool\" && status === \"off\") {\n    const index = toolsRunning.indexOf(topic[2]); //find tool in running tool global array variable.\n    if (index !== -1) {\n        toolsRunning.splice(index, 1); // Removes 1 element at the found index\n        context.set('toolsRunning', toolsRunning);\n    }\n\n    //no tools left running\n    if (toolsRunning.length === 0) {\n\n        //is collector running manually?\n        const parentindex = manualOverride.indexOf(parent);\n        if (parentindex === -1) {\n            //collector not running manually\n            let newMsg = {};\n            newMsg.topic = baseTopic + \"/\" + parent + \"/cmd\";\n            newMsg.payload = '{\"' + type + '\":\"' + topic[2] + '\", \"status\":\"' + status + '\", \"command\":\"off\"}';\n            node.send(newMsg);\n\n            //close all main branch gates here (gates should have timer built in a few seconds longer than dc shut-down)\n            if (Array.isArray(gates)) {\n                for (let i = 0; i < gates.length; i++) {\n                    let newMsg = {};\n                    newMsg.topic = baseTopic + \"/\" + gates[i]['name'] + \"/gate/cmd\";\n                    newMsg.payload = '{\"device\":\"' + topic[2] + '\", \"status\":\"' + status + '\", \"command\":\"close\", \"gateNumber\":\"' + gates[i]['gateNumber'] + '\"}';\n                    node.send(newMsg);\n                }\n            }\n            \n        }\n    } else {\n        // Check the tools that are still running\n        for (let s = 0; s < toolsRunning.length; s++) {\n            var tool = sensorMap[toolsRunning[s]];\n            //Any tools still using gates that are closing? if so, remove from array to leave them open.\n            if (Array.isArray(gates)) {\n                for (let t = 0; t < tool.length; t++) {\n                    var gateName = tool.gates[t]['name'];\n                    var gateNumber = tool.gates[t]['gateNumber'];\n                    for (let i = 0; i < gates.length; i++) {\n                        if(gateName == gates[i]['name'] && gateNumber == gates[i]['name']) {\n                            //gate found, remove from array\n                            gates.splice(i, 1); // Removes 1 element at the found index\n                        }\n                    }\n                }\n            }\n        }\n        // see if any gates are still in the gates arrah, if so,  close them\n        if (Array.isArray(gates)) {\n            for (let i = 0; i < gates.length; i++) {\n                let newMsg = {};\n                newMsg.topic = baseTopic + \"/\" + gates[i]['name'] + \"/gate/cmd\";\n                newMsg.payload = '{\"device\":\"' + topic[2] + '\", \"status\":\"' + status + '\", \"command\":\"close\", \"gateNumber\":\"' + gates[i]['gateNumber'] + '\"}';\n                node.send(newMsg);\n            }\n        }\n    }\n}\n\nreturn \"\";",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 100,
        "wires": [
            [
                "a48a661b76d4243a",
                "2b279b8e29b85dae"
            ]
        ]
    },
    {
        "id": "0e8c6944103c09e3",
        "type": "mqtt-broker",
        "name": "MQTT Server",
        "broker": "mosquitto",
        "port": "1883",
        "clientid": "nodered",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]