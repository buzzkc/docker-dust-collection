# https://esphome.io/guides/configuration-types.html#substitutions
substitutions:

  # substitutions can be changed here if you are using this file directly in the ESPHome dashboard.  The better approach is
  # to incorporate this file as a package using the following lines, and then overwrite these substitutions in your local
  # yaml file by redefining them.
  #
  #

  device_name: dc-s31-vac-control         # **** CHANGE DEVICE NAME TO SOMETHING UNIQUE PER DEVICE.  RENAME YAML FILE TO SAME NAME.    ****
                               # **** USE DASHES (-) INSTEAD OF SPACES OR UNDERSCORE (_).  USE ONLY LOWER CASE LETTERS.     ****

  friendly_name: Dust Collector Vac Control     # **** CHANGE FRIENDLY NAME TO SOMETHING UNIQUE PER DEVICE ****

  #disable_entities:  "true"    # set to "false" to have all entities show up in Home Assistant automatically
  #disable_webserver: "false"   # set to "true" to disable webserver listening on port 80.

  wifi_ap_timeout: 2min    # default to 2 minute timeout for yaml file as package.

  # https://esphome.io/components/esphome.html#esphome-creators-project
  project_name: buzzkc.dust_collector_vac_control
  project_ver_num: "1.0.1"
  project_ver_let: t

  sub_import_url: github://buzzkc/docker-dust-collection/dc-s31-vac-control.yaml

  sub_ota_num_attempts: '15'
  
  device_type: "controller"
  mqtt_broker: "0.0.0.0"
  mqtt_prefix: "buzzkc/dc" 
  relay_pin: 12 # Relay
  led_pin: 13 # Push button LED
  #servo1_pin: 5 
  #servo2_pin: 4
  switch_pin: 0 # Push button
  current_pin: 0 # A0


# https://esphome.io/components/esp8266.html
esp8266:
  board: esp12e
  early_pin_init: false


# https://esphome.io/components/esphome.html
esphome:

  name: $device_name
  friendly_name: $friendly_name
  project:
    name: $project_name
    version: $project_ver_num($project_ver_let)

  on_boot:
    priority: 600
    then:
      - switch.turn_off: relay
      - light.turn_off: device_led
      - script.execute: led_wait_heartbeat

  min_version: 2025.10.0

# This should point to the public location of this yaml file.
dashboard_import:
  package_import_url: $sub_import_url
  import_full_config: false # or true


# https://esphome.io/components/wifi.html
wifi:
  ap:
    ap_timeout: $wifi_ap_timeout


# https://esphome.io/components/captive_portal.html
captive_portal:

# https://esphome.io/components/api.html
api:

# https://esphome.io/components/ota.html
ota:
  - platform: esphome

safe_mode:
  num_attempts: $sub_ota_num_attempts

# https://esphome.io/components/web_server.html
#web_server:

uart:
  rx_pin: RX
  baud_rate: 4800
  parity: EVEN

# https://esphome.io/components/logger.html
logger:
  level: ERROR
  baud_rate: 0 # (UART logging interferes with cse7766)
  logs:
    sensor: ERROR # (Overide any global setting, to VERBOSE will spamming the cse7766 sensors)

globals:
  - id: relay_trigger_source
    type: std::string
    restore_value: no
    initial_value: '"none"'

  - id: off_routine_running
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: show_splash
    type: bool
    restore_value: no
    initial_value: "true"

mqtt:
  broker: !secret mqtt_broker  # ðŸ”¹ Replace with your MQTT broker IP or hostname
  discovery: false
  topic_prefix: ${mqtt_prefix}/${device_name}
  reboot_timeout: 0s
  birth_message:
    topic: ${mqtt_prefix}/${device_name}/birth
    payload: "{\"type\":\"${device_type}\", \"state\":\"birth\"}"
  will_message:
    topic: ${mqtt_prefix}/${device_name}/will
    payload: "{\"type\":\"${device_type}\", \"state\":\"will\"}"
  
  # Send MQTT message when device comes online
  on_connect:
    then:
      - output.turn_off: led_output
      - script.stop: led_wait_heartbeat
      - script.execute: led_heartbeat
      - mqtt.publish:
          topic: ${mqtt_prefix}/${device_name}/status
          payload: '{"state":"online"}'

  # Send MQTT message when device goes offline
  on_disconnect:
    then:
      - output.turn_off: led_output
      - script.stop: led_heartbeat
      - script.execute: led_wait_heartbeat
      - mqtt.publish:
          topic: ${mqtt_prefix}/${device_name}/status
          payload: '{"state":"offline"}'

  on_json_message:
    - topic: ${mqtt_prefix}/${device_name}/cmd
      then:
        - lambda: |-
            if (x.containsKey("command")) {
              std::string cmd = x["command"];
              if (cmd == "toggle") {
                id(toggle_relay).execute();
              } else if (cmd == "on") {
                if (!id(relay).state || (id(off_routine_running) && id(relay).state)) id(toggle_relay).execute();
              } else if (cmd == "off") {
                if (id(relay).state) id(relay_off_routine).execute();
              }
            }

sensor:
  - platform: wifi_signal
    id: wifi_info
    update_interval: 60s
  - platform: cse7766
    current:
      id: current_raw
      accuracy_decimals: 2
      filters:
        - throttle_average: 10s
    voltage:
      id: voltage_raw
      accuracy_decimals: 2
      filters:
        - throttle_average: 60s

switch:
  - platform: gpio
    pin: ${relay_pin}
    id: relay
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - mqtt.publish:
          topic: ${mqtt_prefix}/${device_name}
          payload: !lambda | 
            char buffer[64];
            snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"on\"}");
            return std::string(buffer);
    on_turn_off:
      - mqtt.publish:
          topic: ${mqtt_prefix}/${device_name}
          payload: !lambda | 
            char buffer[64];
            snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"off\"}");
            return std::string(buffer);     


# âœ… All outputs in one block
time:
  - platform: sntp #(required for total_daily_energy)
    id: my_time

output:
  # LED output
  - platform: gpio
    pin: 
      number: ${led_pin}
      inverted: True
    id: led_output

light:
  - platform: binary
    id: device_led
    output: led_output


script:
  - id: relay_on_routine
    mode: restart
    then:
      - switch.turn_on: relay
      - script.stop: led_heartbeat
      - light.turn_on: device_led
      - delay: 1s
      - mqtt.publish:
                topic: ${mqtt_prefix}/${device_name}/status
                payload: '{"type":"${device_type}", relay":"on"}'

  - id: relay_off_routine
    mode: restart
    then:
      - lambda: 'id(off_routine_running) = true;'
      # Flash LED for 10 seconds (500ms on / 500ms off)
      - repeat:
          count: 10
          then:
            - light.toggle: device_led
            - delay: 1s
      
      # Now turn off the relay
      - switch.turn_off: relay

      # Make sure LED is off (final state)
      - light.turn_off: device_led
      - script.execute: led_heartbeat

      # reset global variable to none that tracks if it was toggled on via the button or the current sensor   
      - delay: 1s   
      - lambda: 'id(relay_trigger_source) = "none";'
      - lambda: 'id(off_routine_running) = false;'

  # Toggle relay logic (handles button or MQTT)
  - id: toggle_relay
    then:
      - if:
          condition:
            lambda: |-
                  return (id(off_routine_running) == false) && !(id(relay_trigger_source) == "button") && id(relay).state;
          then:
            - script.execute: relay_off_routine
          else:
            # Interrupt any pending off routine before turning on
            - script.stop: relay_off_routine
            - lambda: 'id(off_routine_running) = false;'
            - script.execute: relay_on_routine

  # --- Heartbeat LED: double flash every 2 seconds ---
  - id: led_heartbeat
    mode: restart
    then:
      - logger.log: "LED heartbeat started (double flash every 2s)"
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.turn_on: device_led
            - delay: 100ms
            - light.turn_off: device_led
            - delay: 100ms
            - light.turn_on: device_led
            - delay: 100ms
            - light.turn_off: device_led
            - delay: 1500ms

# --- Wait Heartbeat LED: flash quickly once every 1 seconds ---
  - id: led_wait_heartbeat
    mode: restart
    then:
      - logger.log: "LED wait heartbeat started (flash once quickly every 1s)"
      - while:
          condition:
            lambda: 'return true;'
          then:
            - light.turn_on: device_led
            - delay: 100ms
            - light.turn_off: device_led
            - delay: 900ms

binary_sensor:
  - platform: gpio
    pin:
      number: ${switch_pin}
      mode: INPUT_PULLUP
      inverted: true
    id: button
    filters:
      - delayed_on: 50ms    # debounce for press
      - delayed_off: 50ms   # debounce for release
    on_press:
      then:
        - if:
            condition:
              lambda: |-
                  return (id(off_routine_running) == false) && id(relay).state;
            then:
              - lambda: 'id(relay_trigger_source) = "manual";'
              - script.execute: toggle_relay
              - script.wait: relay_off_routine
              - mqtt.publish:
                  topic: ${mqtt_prefix}/${device_name}/manual
                  payload: !lambda | 
                    char buffer[64];
                    snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"off\"}");
                    return std::string(buffer);
              
            else:  
              - lambda: 'id(relay_trigger_source) = "button";'
              - script.execute: toggle_relay
              - mqtt.publish:
                  topic: ${mqtt_prefix}/${device_name}/manual
                  payload: !lambda | 
                    char buffer[64];
                    snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\", \"status\":\"on\"}");
                    return std::string(buffer);

interval:
  - interval: 30s
    then:
      - mqtt.publish:
          topic: ${mqtt_prefix}/${device_name}/update
          payload: !lambda | 
            char buffer[64];
            snprintf(buffer, sizeof(buffer), "{\"type\":\"${device_type}\" ,\"status\":\"%s\"}",
                     id(relay).state ? "on" : "off");
            return std::string(buffer);  